{"version":3,"file":"pixi-lights.js","sources":["../src/mixins/Circle.ts","../src/main.ts","../src/lights/light/ViewportQuad.ts","../src/lights/light/Light.ts","../src/lights/shared.ts","../src/lights/light/LightShader.ts","../src/lights/ambientLight/ambient.frag.ts","../src/lights/ambientLight/AmbientLightShader.ts","../src/lights/ambientLight/AmbientLight.ts","../src/lights/pointLight/point.frag.ts","../src/lights/pointLight/PointLightShader.ts","../src/lights/pointLight/PointLight.ts","../src/lights/directionalLight/directional.frag.ts","../src/lights/directionalLight/DirectionalLightShader.ts","../src/lights/directionalLight/DirectionalLight.ts"],"sourcesContent":["import { Circle } from '@pixi/math';\r\n\r\n/**\r\n * Creates vertices and indices arrays to describe this circle.\r\n * @method PIXI.Circle#getMesh\r\n * @param shape\r\n * @param [totalSegments=40] {number} Total segments to build for the circle mesh.\r\n * @param vertices\r\n * @param indices\r\n *  `((totalSegments + 2) * 2)` or more. If not passed it is created for you.\r\n *  be `(totalSegments + 3)` or more. If not passed it is created for you.\r\n * @return {PIXI.Circle~MeshData} Object with verticies and indices arrays\r\n */\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function getCircleMesh(shape: Circle, totalSegments = 40, vertices?: Float32Array, indices?: Uint16Array)\r\n{\r\n    vertices = vertices || new Float32Array((totalSegments + 1) * 2);\r\n    indices = indices || new Uint16Array(totalSegments + 1);\r\n\r\n    const seg = (Math.PI * 2) / totalSegments;\r\n    let indicesIndex = -1;\r\n\r\n    indices[++indicesIndex] = indicesIndex;\r\n\r\n    for (let i = 0; i <= totalSegments; ++i)\r\n    {\r\n        const index = i * 2;\r\n        const angle = seg * i;\r\n\r\n        vertices[index] = Math.cos(angle) * shape.radius;\r\n        vertices[index + 1] = Math.sin(angle) * shape.radius;\r\n\r\n        indices[++indicesIndex] = indicesIndex;\r\n    }\r\n\r\n    indices[indicesIndex] = 1;\r\n\r\n    return { vertices, indices };\r\n}\r\n\r\n/**\r\n * @typedef PIXI.Circle~MeshData\r\n * @property {Float32Array} vertices - Vertices data\r\n * @property {Uint16Array} indices - Indices data\r\n */\r\n","import { Texture } from '@pixi/core';\r\nimport { Group, Layer } from '@pixi/layers';\r\n\r\nexport const diffuseGroup = new Group(0, false);\r\n\r\nexport const normalGroup = new Group(0, false);\r\n\r\nexport const lightGroup = new Group(0, false);\r\n\r\ndiffuseGroup.useRenderTexture = true;\r\nnormalGroup.useRenderTexture = true;\r\n\r\nexport class LayerFinder\r\n{\r\n    lastLayer: Layer = null;\r\n    diffuseTexture: Texture = null;\r\n    normalTexture: Texture = null;\r\n\r\n    check(layer: Layer): void\r\n    {\r\n        if (this.lastLayer === layer)\r\n        {\r\n            return;\r\n        }\r\n        this.lastLayer = layer;\r\n\r\n        const stage = layer._activeStageParent;\r\n        const layerAny = layer as any;\r\n\r\n        this.diffuseTexture = Texture.WHITE;\r\n        this.normalTexture = Texture.WHITE;\r\n\r\n        if (layerAny.diffuseTexture && layerAny.normalTexture)\r\n        {\r\n            this.diffuseTexture = layerAny.diffuseTexture;\r\n            this.normalTexture = layerAny.normalTexture;\r\n        }\r\n        else\r\n        {\r\n            for (let j = 0; j < stage._activeLayers.length; j++)\r\n            {\r\n                const texLayer = stage._activeLayers[j];\r\n\r\n                if (texLayer.group === normalGroup)\r\n                {\r\n                    this.normalTexture = texLayer.getRenderTexture();\r\n                }\r\n                if (texLayer.group === diffuseGroup)\r\n                {\r\n                    this.diffuseTexture = texLayer.getRenderTexture();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    static _instance = new LayerFinder();\r\n}\r\n","import { Quad } from '@pixi/core';\r\nimport { Rectangle } from '@pixi/math';\r\n\r\nexport class ViewportQuad extends Quad\r\n{\r\n    update(viewport: Rectangle): void\r\n    {\r\n        const b = this.buffers[0].data as Float32Array;\r\n\r\n        const x1 = viewport.x;\r\n        const y1 = viewport.y;\r\n        const x2 = viewport.x + viewport.width;\r\n        const y2 = viewport.y + viewport.height;\r\n\r\n        if (b[0] !== x1 || b[1] !== y1\r\n            || b[4] !== x2 || b[5] !== y2)\r\n        {\r\n            b[0] = b[6] = x1;\r\n            b[1] = b[3] = y1;\r\n            b[2] = b[4] = x2;\r\n            b[5] = b[7] = y2;\r\n            this.buffers[0].update();\r\n        }\r\n    }\r\n\r\n    static _instance: ViewportQuad = new ViewportQuad();\r\n}\r\n","import { BLEND_MODES, DRAW_MODES } from '@pixi/constants';\r\nimport { Geometry, Renderer } from '@pixi/core';\r\nimport { Layer } from '@pixi/layers';\r\nimport { Mesh } from '@pixi/mesh';\r\nimport { LayerFinder, lightGroup } from '../../main';\r\nimport { LightShader } from './LightShader';\r\nimport { ViewportQuad } from './ViewportQuad';\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.DisplayObject\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n * @param [brightness=1] {number} The brightness of the light, in range [0, 1].\r\n */\r\nexport class Light extends Mesh\r\n{\r\n    lightHeight: number;\r\n    brightness: number;\r\n    shaderName: string;\r\n    readonly useViewportQuad: boolean;\r\n\r\n    constructor(color = 0x4d4d59, brightness = 0.8, material: LightShader,\r\n        vertices? : Float32Array, indices?: Uint16Array)\r\n    {\r\n        let geom: Geometry;\r\n        let useViewportQuad = false;\r\n\r\n        if (!vertices)\r\n        {\r\n            geom = ViewportQuad._instance;\r\n            useViewportQuad = true;\r\n        }\r\n        else\r\n        {\r\n            geom = new Geometry().addAttribute('aVertexPosition', vertices).addIndex(indices);\r\n        }\r\n\r\n        super(geom, material);\r\n\r\n        this.blendMode = BLEND_MODES.ADD;\r\n\r\n        this.drawMode = useViewportQuad ? DRAW_MODES.TRIANGLE_STRIP : DRAW_MODES.TRIANGLES;\r\n\r\n        /**\r\n         * The height of the light from the viewport.\r\n         *\r\n         * @member {number}\r\n         * @default 0.075\r\n         */\r\n        this.lightHeight = 0.075;\r\n\r\n        /**\r\n         * The falloff attenuation coeficients.\r\n         *\r\n         * @member {number[]}\r\n         * @default [0.75, 3, 20]\r\n         */\r\n        this.falloff = [0.75, 3, 20];\r\n\r\n        /**\r\n         * By default the light uses a viewport sized quad as the mesh.\r\n         */\r\n        this.useViewportQuad = useViewportQuad;\r\n\r\n        // compatibility with old version and its ols bugs :)\r\n        if (color === null)\r\n        {\r\n            color = 0x4d4d59;\r\n        }\r\n\r\n        // color and brightness are exposed through setters\r\n        this.tint = color;\r\n        this.brightness = brightness;\r\n        this.parentGroup = lightGroup;\r\n    }\r\n\r\n    /**\r\n     * The color of the lighting.\r\n     *\r\n     * @member {number}\r\n     * @memberof Light#\r\n     */\r\n    get color(): number\r\n    {\r\n        return this.tint;\r\n    }\r\n    set color(val: number)\r\n    {\r\n        this.tint = val;\r\n    }\r\n\r\n    get falloff(): ArrayLike<number>\r\n    {\r\n        return this.material.uniforms.uLightFalloff;\r\n    }\r\n\r\n    set falloff(value: ArrayLike<number>)\r\n    {\r\n        this.material.uniforms.uLightFalloff[0] = value[0];\r\n        this.material.uniforms.uLightFalloff[1] = value[1];\r\n        this.material.uniforms.uLightFalloff[2] = value[2];\r\n    }\r\n\r\n    lastLayer: Layer;\r\n\r\n    syncShader(renderer: Renderer): void\r\n    {\r\n        const { uniforms } = this.shader;\r\n\r\n        // TODO: actually pass UV's of screen instead of size\r\n        uniforms.uViewSize[0] = renderer.screen.width;\r\n        uniforms.uViewSize[1] = renderer.screen.height;\r\n        uniforms.uViewPixels[0] = renderer.view.width;\r\n        uniforms.uViewPixels[1] = renderer.view.height;\r\n        uniforms.uFlipY = !renderer.framebuffer.current;\r\n        uniforms.uSampler = LayerFinder._instance.diffuseTexture;\r\n        uniforms.uNormalSampler = LayerFinder._instance.normalTexture;\r\n        uniforms.uUseViewportQuad = this.useViewportQuad;\r\n        uniforms.uBrightness = this.brightness;\r\n    }\r\n\r\n    _renderDefault(renderer: Renderer): void\r\n    {\r\n        if (!this._activeParentLayer)\r\n        {\r\n            return;\r\n        }\r\n        LayerFinder._instance.check(this._activeParentLayer);\r\n\r\n        const shader = this.shader as unknown as LightShader;\r\n\r\n        shader.alpha = this.worldAlpha;\r\n        if (shader.update)\r\n        {\r\n            shader.update();\r\n        }\r\n\r\n        renderer.batch.flush();\r\n\r\n        shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);\r\n        if (this.useViewportQuad)\r\n        {\r\n            // TODO: pass the viewport (translated screen) instead\r\n            (this.geometry as ViewportQuad).update(renderer.screen);\r\n        }\r\n\r\n        this.syncShader(renderer);\r\n\r\n        renderer.shader.bind(shader);\r\n\r\n        renderer.state.set(this.state);\r\n\r\n        renderer.geometry.bind(this.geometry, shader);\r\n\r\n        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/no-inferrable-types */\r\nexport const combine: string = `vec3 intensity = diffuse * attenuation;\r\nvec4 diffuseColor = texture2D(uSampler, texCoord);\r\nvec3 finalColor = diffuseColor.rgb * intensity;\r\n\r\ngl_FragColor = vec4(finalColor, diffuseColor.a);\r\n`;\r\n\r\nexport const commonUniforms: string = `uniform sampler2D uSampler;\r\nuniform sampler2D uNormalSampler;\r\n\r\nuniform mat3 translationMatrix;\r\n\r\nuniform vec2 uViewPixels;   // size of the viewport, in pixels\r\nuniform vec2 uViewSize;     // size of the viewport, in CSS\r\n\r\nuniform vec4 uColor;   // light color, alpha channel used for intensity.\r\nuniform float uBrightness;\r\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\r\nuniform float uLightHeight; // light height above the viewport\r\nuniform float uFlipY;             // whether we use renderTexture, FBO is flipped\r\n`;\r\n\r\nexport const computeDiffuse: string = `// normalize vectors\r\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\r\nvec3 L = normalize(lightVector);\r\n\r\n// pre-multiply light color with intensity\r\n// then perform \"N dot L\" to determine our diffuse\r\nvec3 diffuse = uColor.rgb * uBrightness * max(dot(N, L), 0.0);\r\n`;\r\n\r\nexport const computeVertexPosition: string = `vec2 texCoord = gl_FragCoord.xy / uViewPixels;\r\ntexCoord.y = (1.0 - texCoord.y) * uFlipY + texCoord.y * (1.0 - uFlipY); // FBOs positions are flipped.\r\n`;\r\n\r\nexport const loadNormals: string = `vec4 normalColor = texture2D(uNormalSampler, texCoord);\r\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\r\n\r\n// bail out early when normal has no data\r\nif (normalColor.a == 0.0) discard;\r\n`;\r\n\r\nexport const vert: string = `attribute vec2 aVertexPosition;\r\n\r\nuniform bool uUseViewportQuad;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 projectionMatrix;\r\n\r\nvoid main(void) {\r\n    if (uUseViewportQuad) {\r\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    }\r\n    else\r\n    {\r\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    }\r\n}\r\n`;\r\n","import { Texture } from '@pixi/core';\r\nimport { Dict } from '@pixi/utils';\r\nimport { IMeshMaterialOptions, MeshMaterial } from '@pixi/mesh';\r\nimport { Matrix } from '@pixi/math';\r\nimport { vert } from '../shared';\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nexport class LightShader extends MeshMaterial\r\n{\r\n    constructor(options?: IMeshMaterialOptions)\r\n    {\r\n        const uniforms: Dict<any> = {\r\n            translationMatrix: Matrix.IDENTITY.toArray(true),\r\n            // textures from the previously rendered FBOs\r\n            uNormalSampler: Texture.WHITE,\r\n            // size of the renderer viewport, CSS\r\n            uViewSize: new Float32Array(2),\r\n            // same, in PIXELS\r\n            uViewPixels: new Float32Array(2),\r\n            // light falloff attenuation coefficients\r\n            uLightFalloff: new Float32Array([0, 0, 0]),\r\n            // height of the light above the viewport\r\n            uLightHeight: 0.075,\r\n            uBrightness: 1.0,\r\n            uUseViewportQuad: true,\r\n        };\r\n\r\n        if (options.uniforms)\r\n        {\r\n            Object.assign(uniforms, options.uniforms);\r\n        }\r\n\r\n        super(Texture.WHITE, { ...options, uniforms });\r\n    }\r\n\r\n    static defaultVertexSrc: string = vert;\r\n}\r\n","import { commonUniforms, computeVertexPosition, loadNormals } from '../shared';\r\n\r\nexport default `precision highp float;\r\n\r\n${commonUniforms}\r\n\r\nvoid main(void)\r\n{\r\n${computeVertexPosition}\r\n${loadNormals}\r\n    // simplified lambert shading that makes assumptions for ambient color\r\n    vec3 diffuse = uColor.rgb * uBrightness;\r\n    vec4 diffuseColor = texture2D(uSampler, texCoord);\r\n    vec3 finalColor = diffuseColor.rgb * diffuse;\r\n\r\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\r\n}\r\n`;\r\n","import { Program } from '@pixi/core';\nimport { LightShader } from '../light/LightShader';\nimport fragment from './ambient.frag';\n\n/**\n * @class\n * @extends PIXI.lights.LightShader\n * @memberof PIXI.lights\n */\nexport class AmbientLightShader extends LightShader\n{\n    constructor()\n    {\n        super({\n            program: AmbientLightShader._program\n        });\n    }\n\n    static _program= new Program(LightShader.defaultVertexSrc, fragment);\n}\n","import { Light } from '../light/Light';\r\nimport { AmbientLightShader } from './AmbientLightShader';\r\n\r\n/**\r\n * Ambient light is drawn using a full-screen quad\r\n * @class\r\n * @extends PIXI.lights.Light\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n * @param [brightness=0.5] {number} The brightness of the light.\r\n */\r\nexport class AmbientLight extends Light\r\n{\r\n    constructor(color = 0xFFFFFF, brightness = 0.5)\r\n    {\r\n        super(color, brightness, new AmbientLightShader());\r\n    }\r\n}\r\n","import { combine, commonUniforms, computeDiffuse, computeVertexPosition, loadNormals } from '../shared';\r\n\r\nexport default `precision highp float;\r\n\r\n// imports the common uniforms like samplers, and ambient color\r\n${commonUniforms}\r\n\r\nuniform float uLightRadius;\r\n\r\nvoid main()\r\n{\r\n${computeVertexPosition}\r\n${loadNormals}\r\n\r\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\r\n\r\n    // the directional vector of the light\r\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\r\n\r\n    // correct for aspect ratio\r\n    lightVector.x *= uViewSize.x / uViewSize.y;\r\n\r\n    // compute Distance\r\n    float D = length(lightVector);\r\n\r\n    // bail out early when pixel outside of light sphere\r\n    if (D > uLightRadius) discard;\r\n\r\n${computeDiffuse}\r\n\r\n    // calculate attenuation\r\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\r\n\r\n${combine}\r\n}\r\n`;\r\n","import { Program } from '@pixi/core';\r\nimport { LightShader } from '../light/LightShader';\r\nimport fragment from './point.frag';\r\n\r\nexport class PointLightShader extends LightShader\r\n{\r\n    constructor()\r\n    {\r\n        super({\r\n            program: PointLightShader._program,\r\n            uniforms: {\r\n                uLightRadius: 1.0\r\n            }\r\n        });\r\n    }\r\n\r\n    static _program= new Program(LightShader.defaultVertexSrc, fragment);\r\n}\r\n","import { Light } from '../light/Light';\r\nimport { DRAW_MODES } from '@pixi/constants';\r\nimport { Circle } from '@pixi/math';\r\nimport { getCircleMesh } from '../../mixins/Circle';\r\nimport { PointLightShader } from './PointLightShader';\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.lights.Light\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n * @param [brightness=1] {number} The intensity of the light.\r\n * @param [radius=Infinity] {number} The distance the light reaches. You will likely need\r\n *  to change the falloff of the light as well if you change this value. Infinity will\r\n *  use the entire viewport as the drawing surface.\r\n */\r\nexport class PointLight extends Light\r\n{\r\n    constructor(color = 0xFFFFFF, brightness = 1, radius = Infinity)\r\n    {\r\n        if (radius !== Infinity)\r\n        {\r\n            const shape = new Circle(0, 0, radius);\r\n            const { vertices, indices } = getCircleMesh(shape);\r\n\r\n            super(color, brightness, new PointLightShader(), vertices, indices);\r\n\r\n            this.drawMode = DRAW_MODES.TRIANGLE_FAN;\r\n        }\r\n        else\r\n        {\r\n            super(color, brightness, new PointLightShader());\r\n        }\r\n        this.shaderName = 'pointLightShader';\r\n        this.radius = radius;\r\n    }\r\n\r\n    get radius(): number\r\n    {\r\n        return this.material.uniforms.uLightRadius;\r\n    }\r\n\r\n    set radius(value: number)\r\n    {\r\n        this.material.uniforms.uLightRadius = value;\r\n    }\r\n}\r\n","import { combine, commonUniforms, computeDiffuse, computeVertexPosition, loadNormals } from '../shared';\r\n\r\nexport default `precision highp float;\r\n\r\n// imports the common uniforms like samplers, and ambient/light color\r\n${commonUniforms}\r\n\r\nuniform vec2 uLightDirection;\r\n\r\nvoid main()\r\n{\r\n${computeVertexPosition}\r\n${loadNormals}\r\n\r\n    // the directional vector of the light\r\n    vec3 lightVector = vec3(uLightDirection, uLightHeight);\r\n\r\n    // compute Distance\r\n    float D = length(lightVector);\r\n\r\n${computeDiffuse}\r\n\r\n    // calculate attenuation\r\n    float attenuation = 1.0;\r\n\r\n${combine}\r\n}\r\n`;\r\n","import { Program } from '@pixi/core';\nimport { Point } from '@pixi/math';\nimport { LightShader } from '../light/LightShader';\nimport fragment from './directional.frag';\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n */\nexport class DirectionalLightShader extends LightShader\n{\n    constructor()\n    {\n        super({\n            program: DirectionalLightShader._program,\n            uniforms: {\n                uLightRadius: 1.0,\n                uLightDirection: new Point()\n            }\n        });\n    }\n\n    static _program= new Program(LightShader.defaultVertexSrc, fragment);\n}\n","import { Light } from '../light/Light';\nimport { Point } from '@pixi/math';\nimport { DisplayObject } from '@pixi/display';\nimport { DirectionalLightShader } from './DirectionalLightShader';\nimport { Renderer } from '@pixi/core';\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [target] {PIXI.DisplayObject|PIXI.Point} The object in the scene to target.\n */\nexport class DirectionalLight extends Light\n{\n    target: DisplayObject | Point;\n\n    constructor(color = 0xFFFFFF, brightness = 1, target: DisplayObject | Point)\n    {\n        super(color, brightness, new DirectionalLightShader());\n\n        this.target = target;\n    }\n\n    syncShader(renderer: Renderer): void\n    {\n        super.syncShader(renderer);\n\n        const shader = this.material;\n\n        const vec = shader.uniforms.uLightDirection;\n        const wt = this.worldTransform;\n        const twt = (this.target as any).worldTransform;\n\n        let tx: number;\n        let ty: number;\n\n        if (twt)\n        {\n            tx = twt.tx;\n            ty = twt.ty;\n        }\n        else\n        {\n            tx = this.target.x;\n            ty = this.target.y;\n        }\n\n        // calculate direction from this light to the target\n        vec.x = wt.tx - tx;\n        vec.y = wt.ty - ty;\n\n        // normalize\n        const len = Math.sqrt((vec.x * vec.x) + (vec.y * vec.y));\n\n        vec.x /= len;\n        vec.y /= len;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxCA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9JA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;"}